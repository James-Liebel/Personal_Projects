# .cursorrules
# PURPOSE
# Build a Python app that opens an existing Google Doc and "types" a provided STRING
# into it in a human-style manner. The original STRING must remain immutable.
# Execution order:
#   (1) Authentication
#   (2) Human-style typing utilities (no mutation of input string)
#   (3) Insertion-location resolver for Google Docs
#   (4) A tiny, readable main() that wires everything together
# Constraints: efficient, clean, minimal dependencies, clear error messages.

################################################################################
# RUNTIME & DEPENDENCIES
# - Python 3.10+
# - pip packages:
#   google-api-python-client
#   google-auth
#   google-auth-oauthlib
#   python-dotenv (for .env)
#   tenacity (for retries; optional but recommended)
# - Filesystem: store OAuth token at ./.credentials/token.json; client_secret at ./credentials/client_secret.json
# - Scopes: "https://www.googleapis.com/auth/documents"
#           (Optionally "https://www.googleapis.com/auth/drive.readonly" if resolving Doc IDs by search)

################################################################################
# LAYOUT (strict order of imports)
# app/auth/google_auth.py          -> get_docs_client()
# app/typing/human_typer.py        -> type_string_human_style()
# app/docloc/insertion_point.py    -> resolve_insertion_point()
# app/main.py                      -> main() -> authenticate -> resolve index -> type string
# app/types.py                     -> (optional) small dataclasses / TypedDicts

################################################################################
# DOCS API FACTS TO RESPECT
# - No live user caret. Compute an insertion index from:
#     NamedRange, Bookmark, unique marker token (e.g., "<<TYPE_HERE>>"), or fallback (start/end).
# - Insert with docs.documents().batchUpdate(documentId, body={"requests":[...]})
#   using insertText at { "location": { "index": <int> }, "text": "<slice>" }.
# - Fetch the document once to resolve the index; then update index locally as you insert slices.

################################################################################
# INSERTION STRATEGY (try in this order)
# 1) NamedRange: use document.namedRanges["INSERT_HERE"] -> ranges[0].startIndex
# 2) Bookmark: match bookmarkId -> position.index
# 3) Marker token: find a unique text run; record startIndex (optionally remove marker first)
# 4) Fallback: "start" (index 1) or "end" (body.content last segment end index)
# Return: {"index": <int>, "strategy": "<namedRange|bookmark|marker|fallback>"}

################################################################################
# HUMAN-TYPING RULES
# - Treat input text as immutable (never modify it in-place).
# - Insert in chunks (default 12 chars) with jittered delays (e.g., 40–120 ms).
# - Provide fast mode that inserts everything in one request (useful for CI).
# - Provide dry-run mode that logs requests instead of calling the API.
# - Handle 429/5xx with exponential backoff (tenacity), bounded retries.

################################################################################
# AUTH RULES
# - First step in the chain. Use InstalledAppFlow (local browser) by default.
# - Save tokens to ./.credentials/token.json; never commit creds (add to .gitignore).
# - If token refresh fails, re-run InstalledAppFlow.

################################################################################
# CODE STYLE & EFFICIENCY
# - Functions ≤ ~50 lines, single purpose, explicit names.
# - Validate inputs early (non-empty doc_id and text).
# - Fetch doc structure once to compute index; do NOT refetch on every chunk unless concurrency detected.
# - Use batchUpdate with a single insertText per chunk (keeps code simple and calls low).
# - After each insert, increment local index by len(slice) (since subsequent inserts move the cursor forward).

################################################################################
# TESTABILITY
# - Provide dry-run and fast modes.
# - Unit test insertion-point resolution with fixture JSON.
# - Unit test immutability (original text unchanged).

################################################################################
# ERROR HANDLING / EDGE CASES
# - If no anchor found, warn and use fallback ("end" by default).
# - If concurrent edits cause a 400 due to stale index, refetch once and recompute index; retry chunk.
# - If marker token is used, optionally delete it before typing, or type immediately after it (configurable).

################################################################################
# PUBLIC API SURFACE
# - get_docs_client() -> Authorized Docs client
# - resolve_insertion_point(client, doc_id, *, named_range=None, bookmark_id=None, marker=None, fallback="end")
#       -> {"index": int, "strategy": str}
# - type_string_human_style(client, doc_id, start_index, text, *, chunk=12, min_delay_ms=40, max_delay_ms=120,
#       fast=False, dry_run=False) -> None
# - main(): parse CLI/env, call the above, minimal logic

################################################################################
# CURSOR PROMPTS (use these to scaffold files)
# "Create app/auth/google_auth.py exporting get_docs_client(scopes: list[str] = ...) -> Resource (Docs API). Save token to ./.credentials/token.json"
# "Create app/docloc/insertion_point.py exporting resolve_insertion_point(...) implementing NamedRange, Bookmark, Marker, Fallback"
# "Create app/typing/human_typer.py exporting type_string_human_style(...). Keep text immutable. Chunk + jitter + retries. Fast/dry-run flags."
# "Create app/main.py reading DOC_ID/TEXT from env or --doc-id/--text flags, plus --named-range/--bookmark-id/--marker/--fast/--dry-run. Orchestrate auth->loc->type."
#
# DONE WHEN:
# - Running:  python -m app.main --doc-id <ID> --marker "<<TYPE_HERE>>" --text "Hello, world"
#   causes gradual, visible typing at the expected spot with no mutation of the input string.
